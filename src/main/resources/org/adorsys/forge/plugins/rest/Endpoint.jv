package org.adorsys.forge.plugins.rest;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.persistence.metamodel.SingularAttribute;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;


/**
 * 
 */
@Stateless
@Path("${resourcePath}")
public class ${entityEndpointName} {

	@Inject
	private ${entityRepoName} repository;

	@POST
    @Consumes("${contentType}")
	@Produces("application/xml")
	public ${entityName} create(${entityName} entity) {
	    /*
	     * This avoids setting ids from outside. If not create and save will be very
	     * similar, and an entity could be mistakenly overriden by just 
	     * changing it's id. 
	     */
	    entity.setId(null);
		repository.save(entity);
		return entity;
	}

	@DELETE
	@Path("/{id:[0-9][0-9]*}")
   	public Response deleteById(@PathParam("id") ${idType} id){
		${entityName} entity = repository.findBy(id);
		if (entity == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		/*
		 * TODO test if entity listener will be invoked upon deleting through
		 * direct jpql queries.
		 * repository.remove(entity);
		 */
      	repository.removeJPQL(entity.getId());
		return Response.ok(entity).build();
	}

	@PUT
	@Path("/{id:[0-9][0-9]*}")
	@Produces("application/xml")
    @Consumes("${contentType}")
	public ${entityName} update(${entityName} entity) {
		${entityName} saved = repository.save(entity);
		return saved;
	}

    @GET
    @Path("/{id:[0-9][0-9]*}")
    @Produces("${contentType}")
    public Response findById(@PathParam("id") ${idType} id){
		${entityName} entity = repository.findBy(id);

		if (entity == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		return Response.ok(entity).build();
	}

	@GET
    @Produces("${contentType}")
	public List<${entityName}> listAll(@QueryParam("start") int start,
			@QueryParam("max") int max) {
		return repository.findAll(start, max);
	}

	@GET
	@Path("/count")
	public Long count() {
		return repository.count();
	}
	
	@POST
    @Path("/findBy")
    @Produces("${contentType}")
    @Consumes("${contentType}")
	public List<${entityName}> findBy(${entitySearchName} searchInput) {
		SingularAttribute<${entityName}, ?>[] attributes = readSeachAttributes(searchInput);
		return repository.findBy(searchInput.getEntity(),
				searchInput.getStart(), searchInput.getMax(), attributes);
	}

	@POST
	@Path("/countBy")
    @Consumes("${contentType}")
	public Long countBy(${entitySearchName} searchInput) {
		SingularAttribute<${entityName}, ?>[] attributes = readSeachAttributes(searchInput);
		return repository.count(searchInput.getEntity(), attributes);
	}

	@POST
    @Path("/findByLike")
    @Produces("${contentType}")
    @Consumes("${contentType}")
	public List<${entityName}> findByLike(${entitySearchName} searchInput) {
		SingularAttribute<${entityName}, ?>[] attributes = readSeachAttributes(searchInput);
		return repository.findByLike(searchInput.getEntity(),
				searchInput.getStart(), searchInput.getMax(), attributes);
	}


	@POST
	@Path("/countByLike")
    @Consumes("${contentType}")
	public Long countByLike(${entitySearchName} searchInput) {
		SingularAttribute<${entityName}, ?>[] attributes = readSeachAttributes(searchInput);
		return repository.countLike(searchInput.getEntity(), attributes);
	}

	@SuppressWarnings("unchecked")
	private SingularAttribute<${entityName}, ?>[] readSeachAttributes(
			${entitySearchName} searchInput) {
		List<String> fieldNames = searchInput.getFieldNames();
		List<SingularAttribute<${entityName}, ?>> result = new ArrayList<SingularAttribute<${entityName},?>>();
		for (String fieldName : fieldNames) {
			Field[] fields = ${entityName}_.class.getFields();
			for (Field field : fields) {
				if(field.getName().equals(fieldName)){
					try {
						result.add((SingularAttribute<${entityName}, ?>) field.get(null));
					} catch (IllegalArgumentException e) {
						throw new IllegalStateException(e);
					} catch (IllegalAccessException e) {
						throw new IllegalStateException(e);
					}
				}
			}
		}
		return result.toArray(new SingularAttribute[result.size()]);
	}
}