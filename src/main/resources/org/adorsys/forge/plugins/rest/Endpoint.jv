package org.adorsys.forge.plugins.rest;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

import javax.ejb.Stateless;
import javax.inject.Inject;
import javax.persistence.metamodel.SingularAttribute;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.Status;


/**
 * 
 */
@Stateless
@Path("${resourcePath}")
public class ${entityEndpointName} {

	@Inject
	private ${entityRepoName} repository;
	
	<#list entityInfo.getReferencedTypes() as referencedType>
	@Inject
   	private ${referencedType}Merger ${referencedType?uncap_first}Merger;

	</#list>

	@POST
    @Consumes({"application/json","application/xml"})
	@Produces({"application/json","application/xml"})
	public ${entityName} create(${entityName} entity) {
	  	repository.save(attach(entity));
		return entity;
	}

	@DELETE
	@Path("/{id:[0-9][0-9]*}")
   	public Response deleteById(@PathParam("id") ${idType} id){
		${entityName} entity = repository.findBy(id);
		if (entity == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		repository.remove(entity);
		return Response.ok(entity).build();
	}

	@PUT
	@Path("/{id:[0-9][0-9]*}")
	@Produces({"application/json","application/xml"})
    @Consumes({"application/json","application/xml"})
	public ${entityName} update(${entityName} entity) {
		${entityName} saved = repository.save(attach(entity));
		return saved;
	}

    @GET
    @Path("/{id:[0-9][0-9]*}")
	@Produces({"application/json","application/xml"})
    public Response findById(@PathParam("id") ${idType} id){
		${entityName} entity = repository.findBy(id);

		if (entity == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		return Response.ok(entity).build();
	}

	@GET
	@Produces({"application/json","application/xml"})
	public ${entityName}SearchResult listAll(@QueryParam("start") int start,
			@QueryParam("max") int max) {
      List<${entityName}> resultList = repository.findAll(start, max);
      ${entityName}SearchInput searchInput = new ${entityName}SearchInput();
      searchInput.setStart(start);
      searchInput.setMax(max);
      return new ${entityName}SearchResult((long) resultList.size(), resultList, searchInput);
	}

	@GET
	@Path("/count")
	public Long count() {
		return repository.count();
	}
	
	@POST
    @Path("/findBy")
	@Produces({"application/json","application/xml"})
    @Consumes({"application/json","application/xml"})
   public ${entityName}SearchResult findBy(${entityName}SearchInput searchInput)
   {
      SingularAttribute<${entityName}, ?>[] attributes = readSeachAttributes(searchInput);
      Long count = repository.count(searchInput.getEntity(), attributes);
      List<${entityName}> resultList = repository.findBy(searchInput.getEntity(),
            searchInput.getStart(), searchInput.getMax(), attributes);
      return new ${entityName}SearchResult(count, resultList, searchInput);
   }

	@POST
	@Path("/countBy")
    @Consumes({"application/json","application/xml"})
	public Long countBy(${entitySearchName} searchInput) {
		SingularAttribute<${entityName}, ?>[] attributes = readSeachAttributes(searchInput);
		return repository.count(searchInput.getEntity(), attributes);
	}

	@POST
    @Path("/findByLike")
	@Produces({"application/json","application/xml"})
    @Consumes({"application/json","application/xml"})
   public ${entityName}SearchResult findByLike(${entityName}SearchInput searchInput)
   {
      SingularAttribute<${entityName}, ?>[] attributes = readSeachAttributes(searchInput);
      Long countLike = repository.countLike(searchInput.getEntity(), attributes);
      List<${entityName}> resultList = repository.findByLike(searchInput.getEntity(),
            searchInput.getStart(), searchInput.getMax(), attributes);
      return new ${entityName}SearchResult(countLike, resultList, searchInput);
   }


	@POST
	@Path("/countByLike")
    @Consumes({"application/json","application/xml"})
	public Long countByLike(${entitySearchName} searchInput) {
		SingularAttribute<${entityName}, ?>[] attributes = readSeachAttributes(searchInput);
		return repository.countLike(searchInput.getEntity(), attributes);
	}

	@SuppressWarnings("unchecked")
	private SingularAttribute<${entityName}, ?>[] readSeachAttributes(
			${entitySearchName} searchInput) {
		List<String> fieldNames = searchInput.getFieldNames();
		List<SingularAttribute<${entityName}, ?>> result = new ArrayList<SingularAttribute<${entityName},?>>();
		for (String fieldName : fieldNames) {
			Field[] fields = ${entityName}_.class.getFields();
			for (Field field : fields) {
				if(field.getName().equals(fieldName)){
					try {
						result.add((SingularAttribute<${entityName}, ?>) field.get(null));
					} catch (IllegalArgumentException e) {
						throw new IllegalStateException(e);
					} catch (IllegalAccessException e) {
						throw new IllegalStateException(e);
					}
				}
			}
		}
		return result.toArray(new SingularAttribute[result.size()]);
	}
	
   private ${entityName} attach(${entityName} entity){
	   
	<#list entityInfo.getComposed() as field>
	   // composed
	   entity.set${field.getName()?cap_first}(${field.getType()?uncap_first}Merger.bindComposed(entity.get${field.getName()?cap_first}()));

	</#list>
	<#list entityInfo.getAggregated() as field>
	   // aggregated
	   entity.set${field.getName()?cap_first}(${field.getType()?uncap_first}Merger.bindAggregated(entity.get${field.getName()?cap_first}()));

	</#list>
	   
	<#list entityInfo.composedCollections as field>
	   // composed collections
	   ${field.getType()?uncap_first}Merger.bindComposedCollection(entity.get${field.getName()?cap_first}());

	</#list>
	<#list entityInfo.aggregatedCollections as field>
	   // aggregated collection
	   ${field.getType()?uncap_first}Merger.bindAggregatedCollection(entity.get${field.getName()?cap_first}());

	</#list>
	   return entity;
   }
}